#include <iostream>
#include <fstream>
#include <cstdlib>
#include <cstdio>
#include <ctime>
#include <bitset>
#include <vector>
#include <windows.h>
#include <WINDEF.h>
#ifdef FOUR_BYTE_LONG
    typedef long int4;
#endif

typedef unsigned char unit8_t;

#define NUM 100000  

using namespace std;

unsigned char InverseBox[] =
{
	0x0,0x1,0x8d,0xf6,0xcb,0x52,0x7b,0xd1,0xe8,0x4f,0x29,0xc0,0xb0,0xe1,0xe5,0xc7,	
	0x74,0xb4,0xaa,0x4b,0x99,0x2b,0x60,0x5f,0x58,0x3f,0xfd,0xcc,0xff,0x40,0xee,0xb2,	
	0x3a,0x6e,0x5a,0xf1,0x55,0x4d,0xa8,0xc9,0xc1,0xa,0x98,0x15,0x30,0x44,0xa2,0xc2,	
	0x2c,0x45,0x92,0x6c,0xf3,0x39,0x66,0x42,0xf2,0x35,0x20,0x6f,0x77,0xbb,0x59,0x19,	
	0x1d,0xfe,0x37,0x67,0x2d,0x31,0xf5,0x69,0xa7,0x64,0xab,0x13,0x54,0x25,0xe9,0x9,
	0xed,0x5c,0x5,0xca,0x4c,0x24,0x87,0xbf,0x18,0x3e,0x22,0xf0,0x51,0xec,0x61,0x17,	
	0x16,0x5e,0xaf,0xd3,0x49,0xa6,0x36,0x43,0xf4,0x47,0x91,0xdf,0x33,0x93,0x21,0x3b,	
	0x79,0xb7,0x97,0x85,0x10,0xb5,0xba,0x3c,0xb6,0x70,0xd0,0x6,0xa1,0xfa,0x81,0x82,	
	0x83,0x7e,0x7f,0x80,0x96,0x73,0xbe,0x56,0x9b,0x9e,0x95,0xd9,0xf7,0x2,0xb9,0xa4,	
	0xde,0x6a,0x32,0x6d,0xd8,0x8a,0x84,0x72,0x2a,0x14,0x9f,0x88,0xf9,0xdc,0x89,0x9a,	
	0xfb,0x7c,0x2e,0xc3,0x8f,0xb8,0x65,0x48,0x26,0xc8,0x12,0x4a,0xce,0xe7,0xd2,0x62,	
	0xc,0xe0,0x1f,0xef,0x11,0x75,0x78,0x71,0xa5,0x8e,0x76,0x3d,0xbd,0xbc,0x86,0x57,	
	0xb,0x28,0x2f,0xa3,0xda,0xd4,0xe4,0xf,0xa9,0x27,0x53,0x4,0x1b,0xfc,0xac,0xe6,	
	0x7a,0x7,0xae,0x63,0xc5,0xdb,0xe2,0xea,0x94,0x8b,0xc4,0xd5,0x9d,0xf8,0x90,0x6b,	
	0xb1,0xd,0xd6,0xeb,0xc6,0xe,0xcf,0xad,0x8,0x4e,0xd7,0xe3,0x5d,0x50,0x1e,0xb3,
	0x5b,0x23,0x38,0x34,0x68,0x46,0x3,0x8c,0xdd,0x9c,0x7d,0xa0,0xcd,0x1a,0x41,0x1c
};

unsigned char MultiplyBox[256][256];

unsigned char sBox[] =
{ /*  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f */
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, /*0*/ 
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, /*1*/
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, /*2*/
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, /*3*/
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, /*4*/
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, /*5*/
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, /*6*/ 
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, /*7*/
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, /*8*/
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, /*9*/
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, /*a*/
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, /*b*/
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, /*c*/
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, /*d*/
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, /*e*/
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  /*f*/
};


void Randomize();
unit8_t RandomInteger(unit8_t lower,unit8_t upper);
unit8_t gadd(unit8_t a, unit8_t b);
unit8_t gsub(unit8_t a, unit8_t b);
unit8_t gmul(unit8_t a, unit8_t b);
unit8_t CreateMul(unit8_t a, unit8_t b);
void PrintMultiplyBox(void);
unit8_t gdiv(unit8_t a, unit8_t b);
unit8_t CreateInver(unit8_t a);
void PrintInverseBox(void);
unit8_t ginver(unit8_t a);
void quickSort( double s[], int n[], int l, int r);
void checkright(void);

void Randomize(){
    srand((unsigned)time(NULL)); /*以毫秒作为seed*/
}

unit8_t RandomInteger(unit8_t lower,unit8_t upper)
{    
	return(lower+(unit8_t)(rand()%((int)upper-(int)lower+1)));
}


/* Add two numbers in a GF(2^8) finite field */
unit8_t gadd(unit8_t a, unit8_t b) {
    return a ^ b;
}

/* Subtract two numbers in a GF(2^8) finite field */
unit8_t gsub(unit8_t a, unit8_t b) {
    return a ^ b;
}

/* Multiply two numbers in the GF(2^8) finite field defined 
 * by the polynomial x^8 + x^4 + x^3 + x + 1 = 0 */
unit8_t xmul(unit8_t a){
	//int ai=(int)a;
	if(a<128) a=a<<1;
	else{
		a=a<<1;
		a=gadd(a,0x1B);
	}
	return a;
}

unit8_t CreateMul(unit8_t a, unit8_t b) {
    unit8_t p = 0x0;
    int counter;
	if(b%2==1) p=gadd(p,a);
    for (counter = 1; counter < 8; counter++) {
		b=b>>1;
		a=xmul(a);
		if(b%2==1){
			p=gadd(p,a);
		}
    }	
    return p;
}

void PrintMultiplyBox(void)
{
	for(int i=0;i<256; i++)
	{	
		for(int j=0;j<256;j++)
		MultiplyBox[i][j]=(int)CreateMul(i,j);
	}
}
unit8_t gmul(unit8_t a, unit8_t b)
{
	return MultiplyBox[a][b];
}

unit8_t CreateInver(unit8_t a){
	unit8_t int1,int2,int3,int4,int5,int6,int7,int8,int9,int10,int11,int12;
	int1=gmul(a,a);
	int2=gmul(int1,int1);
	int3=gmul(int2,int2);
	int4=gmul(int3,int3);
	int5=gmul(int4,int4);
	int6=gmul(int5,int5);
	int7=gmul(int6,int6);
	int8=gmul(int1,int2);
    int9=gmul(int3,int4);
	int10=gmul(int5,int6);
	int11=gmul(int7,int8);
	int12=gmul(int9,int10);
	return gmul(int11,int12);
}


void PrintInverseBox(void)
{
	ofstream out;
	out.open("InverseBox.txt", ofstream::out);
	unit8_t i;
	for(i=0;i<255; i++)
	{			
		out<<"0x"<<hex<<(int)CreateInver(i)<<",";
		if( i%16 == 15 )
			out<<"\n";
	}
	out<<"0x"<<hex<<(int)CreateInver(i);
}


unit8_t ginver(unit8_t a)
{
	//用于检验逆元的计算是否正确，如不正确输出Error:不正确的被计算数
	//if ((gmul(InverseBox[a], a) - 1)&& a!=0) cout << "Error:"<<(int)a<<"\t";
	return InverseBox[a];
}

void checkright(void)
{
	int m=0;
	int n=0;
	for(int i=0;i<256;i++)
	{
		for(int j=0;j<256;j++)
		{
			if(gmul(i,j)-gmul(j,i))
			{
				cout<<"Error: 乘法  "<<i<<"*"<<j<<endl; 
				m++;
			}
		}
		if((gmul((int)ginver(i), i) - 1)&&i!=0) 
		{
			cout << "Error: 逆元  "<<(int)i<<"   "<<(int)ginver(i)<<endl;
			n++;
		}
	}
	if(m==0) cout<<"乘法计算无误"<<endl;
	if(n==0) cout<<"逆元计算无误"<<endl;
}

unit8_t gdiv(unit8_t a, unit8_t b)
{
	return gmul(a, ginver(b));
}
		
void sBoxAnalysis()
{
    ofstream out;
    out.open("out.txt", ofstream::out);

// sBox Linear Analysis in normal way
	double check[65025];
	int num[65025];
	int temp;
	double dias[10];
	int input[10],output[10];
	double result;
	double p;
	int m=0;
	int n=0;
	int i,j,q,k,r;
    double t=0;

	for(i=0;i<10;i++){
		dias[i]=0;
		input[i]=0;
		output[i]=0;
    }
    
	for(i=1;i<256;i++)
	{
		for(j=1;j<256;j++)
		{
			num[n]=(i<<8)+j;
			n++;
		}
		
	}
	clock_t t1=clock();
	for(i=1;i<256;i=i+1){
		for(q=1;q<256;q=q+1){
			result=0;
			for(j=0;j<256;j++){
		        temp=(j<<8)^sBox[j];
				temp=temp & ((i<<8)^q);
				for (k = 1; k < 16; k++){
			       if (temp & (1 << k)) temp ^= 0x01;//除最低位，其他15位有几个1就加几次0x01；
				}
		        if (!(temp & 0x1)) result++;
			}
			p=result/256;
			check[m]=max(p,1-p);
			m++;
		}
	}
    clock_t t2=clock();
	t=double(t2 - t1) / CLOCKS_PER_SEC;
	clock_t t3=clock();
	quickSort( check, num, 0, 65024);
	clock_t t4=clock();
	double t5=double(t4 - t3) / CLOCKS_PER_SEC;
	for(i=0;i<10;i++)
	{
		dias[i]=check[65024-i];
		input[i]=num[65024-i]>>8;
		output[i]=num[65024-i];
	}


	cout<<"线性分析:"<<t<<endl;
	cout<<"排序:"<<t5<<endl;
	cout<<"input"<<"      "<<"output"<<endl;
	for(r=0;r<10;r++){
		std::bitset<8> d(input[r]); 
        std::bitset<8> e(output[r]);
		std::cout<<d<<" "<<e<<" "<<dias[r]<<endl;
	}
}

void quickSort( double s[], int n[], int l, int r)  
{  
    if (l< r)  
    {     
		double  x = s[l];
        int i = l, j = r, y = n[l];  
        while (i < j)  
        {  
            while(i < j && s[j]>= x) // 从右向左找第一个小于x的数  
                j--;   
            if(i < j) 
			{
                s[i] = s[j];
			    n[i] = n[j];
				i++;
			}
            while(i < j && s[i]<= x) // 从左向右找第一个大于等于x的数  
                i++;   
            if(i < j)
			{
                s[j] = s[i]; 
			    n[j] = n[i];
				j--;
			}
        }  
        s[i] = x;  
		n[i] = y;
        quickSort(s, n, l, i - 1); // 递归调用  
        quickSort(s, n, i + 1, r);  
    } 
}  
int main()
{
    PrintInverseBox();
	PrintMultiplyBox();
	int i;
    Randomize();
    clock_t start_time1 = clock();
    unit8_t a;
    unit8_t b;
    for ( i=0; i<100000; i++) {
       a=RandomInteger(0x0,0xFF);
       b=RandomInteger(0x0,0xFF);
	   gmul(a,b);
    }
    
    clock_t start_time2 = clock();
	cout << "100000次乘法:" << double(start_time2 - start_time1) / CLOCKS_PER_SEC << 's' << endl; 
	 for (i=0; i<100000; i++) {
       a=RandomInteger(0x0,0xFF);
    }
	 clock_t start_time3 = clock();
	 cout << "100000次求逆:" << double(start_time3 - start_time2) / CLOCKS_PER_SEC << 's' << endl;
	 sBoxAnalysis(); 
	 checkright();
	 system("pause");

}


